jsc作为seajs的打包工具，具体功能包括：
(1) js模块化合并；
(2) tmpl.html模板合并打包为js文件；


合并规则I:
(1) jsc执行的目录下面没有搜索到src目录，则不会生成任何的js文件，jsc直接退出到listen阶段（详见jsc.js: if((fs.existsSync || path.existsSync)(modulePath + '/src')){）；
(2) 如果打包的目录下，没有_config文件，则createOut变量为空， 不会生成对应tmpl.js文件；（详见jsc.js：createTMPL()方法，只有存在createOut的时候，才写模板文件）；
(3)	如果要生成tmpl.js文件，甚至修改模板名称，必须要在src目录下面放置一个_config.js文件；则会生成tmpl.js，当然可以在_config.js中的name参数修改为自己的想要的名称；生成的模板文件与src目录平级；
(4) 另外_config.js文件中的tmpl的name参数的值，默认建议为'tmpl.js'，如果是其他值，比如'tmpl_test.js'，会导致生成的js文件为非正常的define方法；直接报错；详见：var code = res.join('').replace('.pack("./tmpl",[],' , '(').replace(/\r\n|\r|\n/g,"\r\n"); 这里的tmpl被替换了，如果是其他的值， 是无法被替换的；那最终的值：define.pack("./commonTmpl",[],function(require, exports, module){var tmpl = { ...
(5) jsc的打包可以支持jsc监听模式，和all一次性的执行所有的合并；唯一的区别在于all带有参数all=true；调用work方法的时候，会执行目录和目录下面的src的路径进行分析处理；理论上会执行多次jsc的打包；那么意味着后面生成的重复
	文件会覆盖前面生成的重复js文件；为了避免类似的问题，我已经处理了类似的问题，jsc执行更快；
(6) 如果不增加_config.js文件，则如果通过jsc或者all生成的时候，默认只会在当前目录下面生成index.js，这个文件是默认的output的文件名；打包了所有的模板和src目录下面的js文件；
(7) 通过jsc的打包方法，可以更加方便的修改_config.js的文件；比如对于直出模板，我们可能并不需要生产的index.js，那么可以在_config.js中，只添加tmpl的内容，不增加js的内容，那么js的文件将不复存在；


